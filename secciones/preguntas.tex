\begin{enumerate}
\item ¿Cuántos primos relativos hay en $Z_{256}$?
Primero, vamos a descomponer en factores primos a 256:
  $$ 256 = 2^8$$
Con la fórmula del totiente de Euler podemos saber el númerp de primos relativos:
 $$\phi(256) = 256 \times \frac{1}{2} = 128$$
Por lo tanto, el número de primos relativos en $ Z_{256} $ es $ \phi(256) = 128 $.
\item pregunta2
\item ¿Cuántas posibles combinaciones no triviales existen para cifrar bytes con César, Decimado
y Afin?
\begin{itemize}
\item \textbf{Cifrado Cesar}

Primero debemos notar que los bytes tienen 256 valores.
Para el \textbf{Cifrado César},  sabemos funciona con un desplazamiento, en el que cada byte se reemplaza con $(x + k) mod 256$ donde k es la llave del desplazamiento. Por lo tanto, si se está usando un desplazamiento, solo tenemos tantas combinaciones como valores, por lo que tenemos \textbf{256 combinaciones}.

\item \textbf{Cifrado Decimado}
El cifrado decimado funciona cuando multiplicamos el valor del byte x por un llave k, para después hacer $mod 256$. Entonces, si qieremos invertir esta operación, $k$ debe der ser primo relativo  de 256, y como ya vimos anteriormente, 256 solo tiene 1\textbf{28 primos relativos} 

\item \textbf{Cifrado Afin}
El cifrado afín es una combinación del cifrado César y el cifrado Decimado, el cuál utiliza la siguiente función $(a\cdot x + b) mod 256$ en el que a es una constante primo relativo y b es una constante de desplazamiento.
Así que la combinación de los dos nos da $128 \cdot 255 = 32, 640$
\end{itemize}
\item ¿Por qué el sistema de archivos de UNIX, aunque un archivo tenga una extensión diferente
(o incluso no tenga), sigue reconociendo al archivo original?
Ya que el sistema de archivos en UNIX no usa las extensiones para reconocer archivos, se debe a que UNIX trabaja directamente con el contenido del archivo, utilizando propiedades internas como los \textit{números mágicos} para identificar el tipo de archivo, por lo que permite que los archivos sean reconocidos y gestionados independientemente de su nombre o extensión. \cite{linux}
\item ¿Por qué los archivos descifrados tienen exactamente el mismo tamaño que antes de cifrar,
pero no pudimos leerlos? ¿Por qué no tuvimos que agregar/quitar nada?
Porque el tamaño no es relavante a la hora de cifrar, ya que no se añade o eliminan bytes, solo se modifican con el cifrado.
\item Ya que base64 no es un cifrado, sino codificación, ¿en qué casos podemos usarlo?
\begin{itemize}
\item Incrustación de datos binarios (como imágenes o archivos de sonido) en HTML, CSS, EML y otros documentos de texto.
\item Garantizar la transferencia, el almacenamiento o la salida seguros de datos que puedan no estar respaldados o dañados.
\item Codificación de certificados SSL, archivos adjuntos de correo electrónico y otra información que requiera el escape de caracteres especiales. \cite{base64}
\end{itemize}
\item Supongamos que estuvieras en Hogwarts y tuvieras que utilizar un búho para comunicarte,
¿cuál crees que sería la mejor opción para mandar mensajes seguros a través de la lechuza?

Para este caso, y con ayuda del video, se puede utilizar Three-pass-protocol, el cual un método para enviar mensajes seguros sin necesidad de intercambiar claves secretas. Para ello, suponiendo que somos Harry Potter, y le queremos enviar un mensaje a Hermione.
\begin{enumerate}
\item Primero ciframos el mensaje $M$ con mi clave $ K_{Harry}$ y enviamos el mensaje cifrado $M'$ a Hermione
\item Ahora, Hermione cifra el mensaje cifrado $ M' $ con su clave $ K_{He} $ obteniendo $ M''$ y lo envía de vuelta a nosotros.
\item  Después, desciframos  $ M'' $ con nuestra clave, eliminando el cifrado y enviamos $ M''' $  de vuelta a Hermione.
\item Finalmente, Hermione descifra $M''' $ con su clave $ K_{He} $ y obtiene el mensaje original $ M $.
\end{enumerate}


\end{enumerate}